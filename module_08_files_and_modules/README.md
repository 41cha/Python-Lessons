# Module 08: Files and Modules

У цьому модулі код перестає жити тільки «в пам’яті» та «в одному файлі». Ви вчитеся:  
1) зберігати дані у **файлах**, щоб вони не зникали після завершення програми;  
2) розбивати код на **модулі**, щоб його можна було імпортувати й перевикористовувати.

***

## Частина 1. Файли: зберігаємо і читаємо дані

### Що таке файл для програми

Файл — це просто **послідовність байтів** на диску, яку Python може прочитати або змінити. Ви вже бачили, як дані живуть у змінних, списках, словниках. Робота з файлами дозволяє ці дані:  

- **зберегти** між запусками програми (логі, налаштування, результати);  
- **прочитати** вже існуючу інформацію (текст, CSV, конфіг). 

***

### open(): як «відкрити двері» до файлу

Базова функція:

```python
f = open("data.txt", "r", encoding="utf-8")
# працюємо з f
f.close()
```

Перший аргумент — шлях до файлу, другий — **режим**:

- `"r"` — читання (read), файл має існувати;  
- `"w"` — запис (write), створює файл або **перезаписує** існуючий;  
- `"a"` — дописування (append), додає в кінець файла;  
- можна додати `"b"` для бінарного режиму, але в цьому модулі працюємо з текстом.  

`encoding="utf-8"` — важливо для коректної роботи з українськими/латинськими літерами.

***

### with open(...): автоматично закривати файл

Рекомендований шаблон:

```python
with open("data.txt", "r", encoding="utf-8") as f:
    content = f.read()
    print(content)
```

Переваги `with`:

- файл **гарантовано** буде закрито після виходу з блоку, навіть якщо станеться помилка;  
- код стає компактнішим і безпечнішим.  

У цьому модулі всі приклади з файлами робляться через `with`.

***

### Читання файлів

Є кілька способів прочитати текстовий файл.

#### Прочитати весь файл одразу

```python
with open("data.txt", "r", encoding="utf-8") as f:
    content = f.read()
    print(content)
```

Підходить для невеликих файлів, коли вам потрібен увесь текст одразу (наприклад, щоб показати користувачу, або зберегти в змінну для подальшої обробки).

***

#### Читати файл по рядках

```python
with open("data.txt", "r", encoding="utf-8") as f:
    for line_number, line in enumerate(f, start=1):
        line = line.rstrip("\n")
        print(f"{line_number}: {line}")
```

Особливості:

- файл — це **ітерабельний об’єкт**;  
- кожна ітерація `for` дає наступний рядок;  
- корисно для великих файлів або коли потрібно обробляти рядки по одному (лог-файли, CSV тощо).  

Тут ви бачите, як поєднуються цикли (`for`) і файли.

***

### Запис у файл: "w" та "a"

#### Перезапис файла ("w")

```python
with open("output.txt", "w", encoding="utf-8") as f:
    f.write("First line\n")
    f.write("Second line\n")
```

- якщо файл існує — він **очищається**;  
- якщо не існує — буде створений. 

Це підходить для «результатів програми», які кожен раз треба формувати заново (наприклад, звіт).

***

#### Дописування в кінець ("a")

```python
with open("log.txt", "a", encoding="utf-8") as f:
    f.write("New log entry\n")
```

- вміст файлу зберігається;  
- нові рядки додаються знизу.  

Це класичний спосіб робити **лог-файли**: кожен запуск/подія додає рядок з описом.

***

### Лічильники, форматування, простий аналіз

Після того як ви вмієте читати файли по рядках, можна робити прості аналізи:

- рахуємо кількість рядків;  
- пропускаємо пусті рядки;  
- обробляємо CSV: розбиваємо рядок за комою, беремо `name` та `age`. 

Приклад простого CSV-парсингу:

```python
with open("data.csv", "r", encoding="utf-8") as f:
    first_line = True
    for line in f:
        line = line.strip()
        if not line:
            continue

        if first_line:
            first_line = False  # пропускаємо заголовок
            continue

        name, age = line.split(",")
        print(f"Name: {name}, Age: {age}")
```

Це перший крок до роботи з «табличними» даними без складних бібліотек.

***

## Частина 2. Модулі: розбиваємо код на частини

### Що таке модуль

**Модуль** — це просто файл `.py`, який можна **імпортувати** в інший код. Він містить: 

- функції;  
- змінні;  
- класи;  
- інший код.  

Наприклад, стандартний модуль `math` дає доступ до математичних функцій:

```python
import math

print(math.sqrt(16))  # 4.0
print(math.floor(3.7))  # 3
print(math.ceil(3.1))   # 4
```

Модулі дозволяють **не винаходити велосипед**: замість писати власну реалізацію кореня чи округлення, ви берете готове рішення.

***

### import: як підключити модуль

Основні варіанти:

```python
import math

from math import sqrt, floor
```

- `import math` — імпортує весь модуль, звернення через `math.sqrt`;  
- `from math import sqrt` — імпортує **конкретні імена** прямо в поточний простір імен, звернення `sqrt(16)`.  

У навчальних прикладах добре бачити, звідки що взялося, тому `import math` часто читабельніший.

***

### Власний модуль: helper.py

Ви можете створювати **свої** модулі.

1. Створюєте файл `helper.py` поруч із `exercises.py`.  
2. Пишете туди, наприклад:

```python
# helper.py

def add(a, b):
    return a + b

def multiply(a, b):
    return a * b
```

3. У `exercises.py`:

```python
from helper import add, multiply

print(add(2, 3))
print(multiply(4, 5))
```

Умови, щоб імпорт працював просто:

- файли мають бути в **одній папці** (як у цьому модулі);  
- імпорт робиться **без .py**, просто `import helper`.  

Це і є перший крок до організації проєкту з кількох файлів: логіка розділяється на «утиліти», «моделі», «головний скрипт» тощо.

***

## Як це все пов’язано з попередніми модулями

У цьому модулі ви комбінуєте:  

- **рядки і цикли** — щоб обробляти вміст файлів;  
- **функції** — щоб оформлювати логіку роботи з файлами в окремі блоки;  
- **модулі** — щоб розносити логіку по різних файлах і перевикористовувати її.  

Файли дають **постійність даних**, модулі — **структуру коду**. Разом це робить ваші програми більш «схожими на справжні» — з логами, конфігами, розбиттям на файли, а не одним величезним скриптом.