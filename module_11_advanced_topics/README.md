# Module 11: Advanced Topics

Цей модуль знайомить із «післябазовими» можливостями Python, які роблять код коротшим і виразнішим: **comprehensions**, `enumerate`, `zip` і `lambda`. Вони не змінюють можливості мови, але сильно впливають на стиль і зручність коду.

## List / dict comprehension: компактне створення колекцій

**List comprehension** — це спосіб створити новий список «в один рядок» із існуючої послідовності.

Замість:

```python
squares = []
for x in range(1, 11):
    squares.append(x * x)
```

можна написати:

```python
squares = [x * x for x in range(1, 11)]
```

Загальний шаблон:

```python
[new_value for element in iterable if condition]
```

- частина `new_value` — як трансформуємо елемент;  
- `for element in iterable` — по чому ітеруємось;  
- `if condition` — необов’язковий фільтр.  

Приклади:

- тільки парні числа: `[n for n in numbers if n % 2 == 0]`;
- усі слова у верхньому регістрі: `[w.upper() for w in words]`.

**Dict comprehension** працює так само, але повертає словник:

```python
squares = {x: x * x for x in range(1, 6)}
```

Важливо не зловживати складними comprehension з кількома вкладеними умовами — якщо рядок стає важким для читання, краще повернутися до звичайного циклу. 

## enumerate: індекс + елемент одночасно

Часто потрібно мати і **індекс**, і **значення** під час перебору списку. `enumerate` додає лічильник до кожного елемента.

```python
fruits = ["apple", "banana", "cherry"]

for index, value in enumerate(fruits):
    print(f"{index}: {value}")
```

- за замовчуванням індекси починаються з 0, але можна задати `start=1`;  
- це заміна патерну `for i in range(len(list))`, який менш читабельний. 

## zip: синхронний обхід кількох списків

`zip` поєднує кілька послідовностей «паралельно», повертаючи кортежі елементів на однакових позиціях. 

```python
names = ["Andrii", "Maria", "Oleh"]
ages = [20, 19, 22]

for name, age in zip(names, ages):
    print(f"{name} is {age} years old")
```

- зручно, коли дані логічно «йдуть парами» або трійками (ім’я + вік, товар + ціна);  
- зупиняється на кінці **найкоротшої** послідовності.

Комбінація `enumerate` + `zip` дозволяє одночасно мати індекс і кілька значень:

```python
for index, (product, price) in enumerate(zip(products, prices)):
    print(f"{index}: {product} - {price}")
```  

## lambda: маленькі анонімні функції

`lambda` створює короткі **анонімні** функції — без імені: 

```python
square = lambda x: x * x
print(square(5))  # 25
```

Основний сценарій — передача невеликої функції як аргумент іншій функції, наприклад для сортування:

```python
students = [("Andrii", 20), ("Maria", 19), ("Oleh", 22)]
sorted_students = sorted(students, key=lambda item: item [realpython](https://realpython.com/list-comprehension-python/))
```

Тут `lambda item: item` каже `sorted`, що сортувати треба за другим елементом кортежу — віком. 

`lambda` добре підходить, коли:

- функція настільки проста, що заради неї не хочеться писати `def` вище;  
- вона використовується в одному місці (наприклад, разовий ключ сортування).  

Якщо логіка росте, краще замінити `lambda` на іменовану функцію для читабельності. 

## Як усе це працює разом

Інструменти цього модуля — це **синтаксичний цукор** поверх уже знайомих конструкцій (циклів, умов, функцій), але:

- comprehension дають компактне створення списків/словників з фільтрацією й трансформацією;  
- `enumerate` і `zip` роблять обхід колекцій більш природним і без «ручного» керування індексами; 
- `lambda` дозволяє «вбудовувати» маленькі функції прямо там, де вони потрібні (наприклад, у `sorted`). 

Ці прийоми часто зустрічаються в чужому коді, тож мета модуля — навчити вас не лише ними користуватися, а й **розуміти й читати** «пайтонічний» стиль, коли трансформації даних виражені коротко та виразно.