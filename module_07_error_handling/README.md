Ось оновлений, більш концептуальний `README.md` для `module_07_error_handling/`.

***

# Module 07: Error Handling

У попередніх модулях ми вважали, що все йде «ідеально»: користувач вводить правильні дані, файли існують, ділення на нуль ніхто не робить. У реальних програмах це майже ніколи не так. **Обробка помилок** дозволяє програмі не падати при першій проблемі, а реагувати передбачувано й безпечно.

## Що таке помилка і виняток

Під час виконання програми можуть виникати два великі типи проблем: 

- **Синтаксичні помилки** (syntax errors) — неправильний код, який навіть не запускається: пропущена дужка, двокрапка тощо. Їх знаходить інтерпретатор до запуску.  
- **Винятки** (exceptions) — помилки **під час виконання** вже синтаксично правильного коду: ділення на нуль, індекс за межами списку, відкриття неіснуючого файлу, некоректний ввід.

При винятку Python створює об’єкт помилки (наприклад, `ZeroDivisionError`) і, якщо його ніхто не обробляє, зупиняє програму з traceback’ом. 

Приклади типових вбудованих винятків: 

- `ZeroDivisionError` — ділення на нуль.  
- `ValueError` — некоректне значення, наприклад `int("abc")`.  
- `IndexError` — індекс список/рядка поза межами.  
- `FileNotFoundError` — файл не знайдено.  

Мета цього модуля — навчитися **ловити** такі ситуації та керувати ними.

***

## Механіка try / except

Базова конструкція:

```python
try:
    # небезпечний код
    result = a / b
except ZeroDivisionError:
    # що робити, якщо сталася саме ця помилка
    print("Cannot divide by zero")
```

Логіка:

- усе в блоці `try` виконується «як зазвичай», доки не трапиться виняток;  
- якщо виникає виняток указаного типу (`ZeroDivisionError`), Python перескакує в відповідний `except` і **не** продовжує виконання решти `try`;  
- якщо виняток не виник — `except` пропускається.  

Краще **ловити конкретні винятки**, а не писати голий `except:` або `except Exception:` без потреби, щоб не ховати несподівані баги.

***

## Ланцюжок try / except з кількома типами помилок

Можна обробляти різні помилки по‑різному, наприклад при доступі до елементів списку:
```python
items = ["apple", "banana", "orange"]

try:
    index = int(input("Index: "))
    print(items[index])
except ValueError:
    print("Index must be an integer")
except IndexError:
    print("Index out of range")
```

- `ValueError` — якщо неможливо перетворити введення на число.  
- `IndexError` — якщо індекс вийшов за межі списку.  

Так код стає зрозумілим: кожен тип проблеми має своє повідомлення.

***

## Блок else: код, який виконується тільки без помилок

Іноді зручно розділити логіку на:

- «небезпечну» частину (`try`),  
- реакцію на помилки (`except`),  
- і «успішний» шлях (`else`).

```python
try:
    result = a / b
except ZeroDivisionError:
    print("Error: division by zero")
else:
    print("Result:", result)
```

- Якщо **не було** винятку, виконується `else`.  
- Якщо була помилка, `else` пропускається.  

Це робить код чистішим: обчислення — в `try`, обробка помилок — в `except`, логіка «успіху» — в `else`.

***

## Блок finally: код, який виконується завжди

`finally` гарантовано виконується **у будь‑якому випадку** — і коли помилка є, і коли її немає.

```python
try:
    value = int(input("Enter number: "))
    print("OK:", value)
except ValueError:
    print("Not a number")
finally:
    print("Done")
```

Типовий сценарій — прибирання ресурсів: закрити файл, з’єднання з БД тощо. У навчальних прикладах ми просто показуємо, що цей блок спрацьовує завжди.

***

## Файли і винятки

Робота з файлами — класичне місце для винятків: файл може не існувати, не бути доступним, мати неправильну кодування тощо.

```python
filename = input("Filename: ")

try:
    with open(filename, "r", encoding="utf-8") as f:
        content = f.read()
        print(content)
except FileNotFoundError:
    print("File not found")
```

Тут ми:

- намагаємось відкрити файл у `try`;  
- якщо файлу немає — ловимо `FileNotFoundError` і не даємо програмі впасти з traceback’ом;  
- користувач отримує зрозуміле повідомлення.  

***

## raise: свої умови правильності

Не всі помилки — це помилки інтерпретатора. Часто це **логічні заборони** у вашій предметній області. Наприклад, вік не може бути від’ємним. 

```python
age = int(input("Enter age: "))

if age < 0:
    raise ValueError("Age cannot be negative")
```

- `raise` створює виняток вручну.  
- Це краще, ніж «мовчки» приймати неправильні дані або повертати спеціальні магічні значення.  

Зазвичай `raise` поєднують із `try/except` на вищому рівні:

```python
try:
    age = int(input("Enter age: "))
    if age < 0:
        raise ValueError("Age cannot be negative")
    print("Age:", age)
except ValueError as e:
    print("Error:", e)
```

Так функція або кодова гілка чітко декларує: з такими даними продовжувати виконання не можна.

***

## Навіщо все це в реальних програмах

Обробка винятків — це не просто «щоб не було червоного traceback’а». Вона потрібна для: 

- **Стійкості**: програма продовжує працювати навіть при помилках вводу або зовнішніх ресурсів.  
- **Безпеки**: ви контролюєте, які повідомлення показуються користувачу, і не розкриваєте внутрішні деталі.  
- **Читабельності**: окремі гілки для нормального виконання, для помилкових ситуацій і для прибирання.  
- **Контрактів у коді**: через `raise` можна чітко сказати «такий стан — некоректний».  

У цьому модулі важливо не просто запам’ятати синтаксис `try/except`, а саме навчитися **думати про помилки як про нормальну частину життя програми** і проєктувати реакції на них.