Ось оновлений, більш концептуальний `README.md` для `module_07_error_handling/`.

***

# Module 07: Error Handling

У попередніх модулях ми вважали, що все йде «ідеально»: користувач вводить правильні дані, файли існують, ділення на нуль ніхто не робить. У реальних програмах це майже ніколи не так. **Обробка помилок** дозволяє програмі не падати при першій проблемі, а реагувати передбачувано й безпечно.

## Що таке помилка і виняток

Під час виконання програми можуть виникати два великі типи проблем: 

- **Синтаксичні помилки** (syntax errors) — неправильний код, який навіть не запускається: пропущена дужка, двокрапка тощо. Їх знаходить інтерпретатор до запуску.  
- **Винятки** (exceptions) — помилки **під час виконання** вже синтаксично правильного коду: ділення на нуль, індекс за межами списку, відкриття неіснуючого файлу, некоректний ввід.

При винятку Python створює об’єкт помилки (наприклад, `ZeroDivisionError`) і, якщо його ніхто не обробляє, зупиняє програму з traceback’ом. 

Приклади типових вбудованих винятків: 

- `ZeroDivisionError` — ділення на нуль.  
- `ValueError` — некоректне значення, наприклад `int("abc")`.  
- `IndexError` — індекс список/рядка поза межами.  
- `FileNotFoundError` — файл не знайдено.  

Мета цього модуля — навчитися **ловити** такі ситуації та керувати ними.

***

## Механіка try / except

Базова конструкція:

```python
try:
    # небезпечний код
    result = a / b
except ZeroDivisionError:
    # що робити, якщо сталася саме ця помилка
    print("Cannot divide by zero")
```

Логіка:

- усе в блоці `try` виконується «як зазвичай», доки не трапиться виняток;  
- якщо виникає виняток указаного типу (`ZeroDivisionError`), Python перескакує в відповідний `except` і **не** продовжує виконання решти `try`;  
- якщо виняток не виник — `except` пропускається.  

Краще **ловити конкретні винятки**, а не писати голий `except:` або `except Exception:` без потреби, щоб не ховати несподівані баги.

***

## Ланцюжок try / except з кількома типами помилок

Можна обробляти різні помилки по‑різному, наприклад при доступі до елементів списку:
```python
items = ["apple", "banana", "orange"]

try:
    index = int(input("Index: "))
    print(items[index])
except ValueError:
    print("Index must be an integer")
except IndexError:
    print("Index out of range")
```

- `ValueError` — якщо неможливо перетворити введення на число.  
- `IndexError` — якщо індекс вийшов за межі списку.  

Так код стає зрозумілим: кожен тип проблеми має своє повідомлення.

***

## Блок else: код, який виконується тільки без помилок

Іноді зручно розділити логіку на:

- «небезпечну» частину (`try`),  
- реакцію на помилки (`except`),  
- і «успішний» шлях (`else`).

```python
try:
    result = a / b
except ZeroDivisionError:
    print("Error: division by zero")
else:
    print("Result:", result)
```

- Якщо **не було** винятку, виконується `else`.  
- Якщо була помилка, `else` пропускається.  

Це робить код чистішим: обчислення — в `try`, обробка помилок — в `except`, логіка «успіху» — в `else`.

***

## Блок finally: код, який виконується завжди

`finally` гарантовано виконується **у будь‑якому випадку** — і коли помилка є, і коли її немає.

```python
try:
    value = int(input("Enter number: "))
    print("OK:", value)
except ValueError:
    print("Not a number")
finally:
    print("Done")
```

Типовий сценарій — прибирання ресурсів: закрити файл, з’єднання з БД тощо. У навчальних прикладах ми просто показуємо, що цей блок спрацьовує завжди.

***

## Файли і винятки

Робота з файлами — класичне місце для винятків: файл може не існувати, не бути доступним, мати неправильну кодування тощо.

```python
filename = input("Filename: ")

try:
    with open(filename, "r", encoding="utf-8") as f:
        content = f.read()
        print(content)
except FileNotFoundError:
    print("File not found")
```

Тут ми:

- намагаємось відкрити файл у `try`;  
- якщо файлу немає — ловимо `FileNotFoundError` і не даємо програмі впасти з traceback’ом;  
- користувач отримує зрозуміле повідомлення.  

***

## raise: свої умови правильності

Не всі помилки — це помилки інтерпретатора. Часто це **логічні заборони** у вашій предметній області. Наприклад, вік не може бути від’ємним. 

```python
age = int(input("Enter age: "))

if age < 0:
    raise ValueError("Age cannot be negative")
```

- `raise` створює виняток вручну.  
- Це краще, ніж «мовчки» приймати неправильні дані або повертати спеціальні магічні значення.  

Зазвичай `raise` поєднують із `try/except` на вищому рівні:

```python
try:
    age = int(input("Enter age: "))
    if age < 0:
        raise ValueError("Age cannot be negative")
    print("Age:", age)
except ValueError as e:
    print("Error:", e)
```

Так функція або кодова гілка чітко декларує: з такими даними продовжувати виконання не можна.

***

## Навіщо все це в реальних програмах

Обробка винятків — це не просто «щоб не було червоного traceback’а». Вона потрібна для: 

- **Стійкості**: програма продовжує працювати навіть при помилках вводу або зовнішніх ресурсів.  
- **Безпеки**: ви контролюєте, які повідомлення показуються користувачу, і не розкриваєте внутрішні деталі.  
- **Читабельності**: окремі гілки для нормального виконання, для помилкових ситуацій і для прибирання.  
- **Контрактів у коді**: через `raise` можна чітко сказати «такий стан — некоректний».  

У цьому модулі важливо не просто запам’ятати синтаксис `try/except`, а саме навчитися **думати про помилки як про нормальну частину життя програми** і проєктувати реакції на них.

## Огляд вправ модуля

### Task 1: Safe division

- Ввід: два числа `a` і `b`.  
- Поведінка:
  - спробувати обчислити `a / b`;  
  - якщо `b = 0`, вивести `"Cannot divide by zero"`.  
- Цілі:
  - перехоплення `ZeroDivisionError`;  
  - не допустити падіння програми при діленні на нуль. 

### Task 2: Safe integer input

- Ввід: рядок від користувача.  
- Поведінка:
  - спробувати перетворити рядок на `int`;  
  - якщо введено не число — вивести `"Invalid integer"`.  
- Цілі:
  - перехоплення `ValueError`, який виникає при некоректному перетворенні `int(text)`;  
  - демонстрація, як «очищати» ввід користувача.

### Task 3: Safe list index

- Є список `["apple", "banana", "orange"]`.  
- Ввід: індекс від користувача.  
- Поведінка:
  - якщо індекс в межах — вивести елемент;  
  - якщо індекс за межами — `"Index out of range"`;  
  - якщо ввели не число — `"Index must be an integer"`.  
- Цілі:
  - комбінований `try` з кількома `except` (ValueError + IndexError).

### Task 4: File reader with error handling

- Ввід: ім’я файлу.  
- Поведінка:
  - спробувати відкрити файл і вивести його вміст;  
  - якщо файл не знайдено — `"File not found"`.  
- Цілі:
  - перехоплення `FileNotFoundError`;  
  - безпечне читання файлів за допомогою `with open(...)`. 

### Task 5: Custom error message with else

- Ввід: два числа.  
- Поведінка:
  - спробувати поділити перше на друге;  
  - якщо ділення на 0 — показати помилку в `except`;  
  - якщо все добре — вивести результат у блоці `else`.  
- Цілі:
  - показати, як `else` виконується тільки після успішного `try`, без винятків.

### Task 6: Finally block

- Ввід: рядок із числом.  
- Поведінка:
  - спробувати перетворити на `int`;  
  - якщо ок — вивести число;  
  - якщо помилка — вивести повідомлення;  
  - завжди вивести `"Done"` у `finally`.  
- Цілі:
  - показати, що `finally` виконується завжди: і при успісі, і при помилці.

### Task 7 (optional): raise ValueError for negative age

- Ввід: вік користувача як `int`.  
- Поведінка:
  - якщо вік < 0 — явно зробити `raise ValueError("Age cannot be negative")`;  
  - перехопити виняток і вивести повідомлення.  
- Цілі:
  - практичне використання `raise` для сигналізації про некоректні дані;  
  - розуміння різниці між помилками перетворення (`ValueError` при `int()`) і логічною помилкою (негативний вік).

***

## Рекомендований порядок роботи

1. Прочитати цей `README.md`, особливо блок про `try/except/else/finally` та `raise`.
2. Відкрити `exercises.py` і виконати задачі 1–6; задачу 7 залишити як додатковий челендж.  
3. Для кожної задачі:
   - продумати, де саме може статися помилка;  
   - обгорнути проблемний код у `try`;  
   - у `except` обробити **конкретний** тип винятку;  
   - за потреби використати `else` і `finally`.  
4. Перевірити програму з різними даними:
   - ділення на 0 і нормальні числа;  
   - коректні/некоректні цілі числа;  
   - існуючий/неіснуючий файл;  
   - позитивний, нульовий та від’ємний вік.  
5. Після цього відкрити `solutions.py`, порівняти свій підхід з еталонним і звернути увагу:
   - чи не використовується занадто загальний `except Exception`;  
   - чи повідомлення для користувача зрозумілі.