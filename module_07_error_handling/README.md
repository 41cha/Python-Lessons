# Module 07: Error Handling

У цьому модулі студенти вчаться обробляти помилки за допомогою `try`, `except`, `else`, `finally` та `raise`. Це дозволяє робити програми більш надійними: не падати при неправильному вводі, діленні на нуль чи відсутньому файлі, а показувати зрозумілі повідомлення. 

## Навчальні цілі

Після проходження модуля студент зможе:

- Використовувати `try/except` для перехоплення типових помилок (ZeroDivisionError, ValueError, IndexError, FileNotFoundError). 
- Застосовувати `else` для коду, який виконується тільки якщо помилки не було, та `finally` для коду, який виконується завжди.
- Використовувати `raise` для явного генерування винятків із власним повідомленням.
- Проєктувати прості, але стійкі до помилок сценарії: введення даних, ділення, доступ до списків, читання файлів.

## Основна ідея обробки винятків

### try і except

Базовий шаблон:

```python
try:
    # код, де може трапитися помилка
    result = a / b
except ZeroDivisionError:
    # що робити, якщо сталася конкретна помилка
    print("Cannot divide by zero")
```

- `try` — блок, де ми «ризикуємо» (можлива помилка).
- `except` — блок, де ми обробляємо виняток і не даємо програмі впасти.

### else

`else` виконується **тільки якщо помилки не було**:

```python
try:
    result = a / b
except ZeroDivisionError:
    print("Error")
else:
    print("Result:", result)
```

Це зручно, щоб відділити «успішний» сценарій від обробки помилок.

### finally

`finally` виконується **завжди**, і при помилці, і без неї. Його часто використовують для прибирання ресурсів (закрити файл, з’єднання тощо).

```python
try:
    value = int(text)
except ValueError:
    print("Not an integer")
finally:
    print("Done")
```

### raise

`raise` дозволяє **навмисно** створити виняток, якщо ситуація некоректна:

```python
if age < 0:
    raise ValueError("Age cannot be negative")
```

Так ми чітко сигналізуємо про помилковий стан у програмі. 

***

## Огляд вправ модуля

### Task 1: Safe division

- Ввід: два числа `a` і `b`.  
- Поведінка:
  - спробувати обчислити `a / b`;  
  - якщо `b = 0`, вивести `"Cannot divide by zero"`.  
- Цілі:
  - перехоплення `ZeroDivisionError`;  
  - не допустити падіння програми при діленні на нуль. 

### Task 2: Safe integer input

- Ввід: рядок від користувача.  
- Поведінка:
  - спробувати перетворити рядок на `int`;  
  - якщо введено не число — вивести `"Invalid integer"`.  
- Цілі:
  - перехоплення `ValueError`, який виникає при некоректному перетворенні `int(text)`;  
  - демонстрація, як «очищати» ввід користувача. 

### Task 3: Safe list index

- Є список `["apple", "banana", "orange"]`.  
- Ввід: індекс від користувача.  
- Поведінка:
  - якщо індекс в межах — вивести елемент;  
  - якщо індекс за межами — `"Index out of range"`;  
  - якщо ввели не число — `"Index must be an integer"`.  
- Цілі:
  - комбінований `try` з кількома `except` (ValueError + IndexError).

### Task 4: File reader with error handling

- Ввід: ім’я файлу.  
- Поведінка:
  - спробувати відкрити файл і вивести його вміст;  
  - якщо файл не знайдено — `"File not found"`.  
- Цілі:
  - перехоплення `FileNotFoundError`;  
  - безпечне читання файлів за допомогою `with open(...)`.

### Task 5: Custom error message with else

- Ввід: два числа.  
- Поведінка:
  - спробувати поділити перше на друге;  
  - якщо ділення на 0 — показати помилку в `except`;  
  - якщо все добре — вивести результат у блоці `else`.  
- Цілі:
  - показати, як `else` виконується тільки після успішного `try`, без винятків.

### Task 6: Finally block

- Ввід: рядок із числом.  
- Поведінка:
  - спробувати перетворити на `int`;  
  - якщо ок — вивести число;  
  - якщо помилка — вивести повідомлення;  
  - завжди вивести `"Done"` у `finally`.  
- Цілі:
  - показати, що `finally` виконується завжди: і при успісі, і при помилці.

### Task 7 (optional): raise ValueError for negative age

- Ввід: вік користувача як `int`.  
- Поведінка:
  - якщо вік < 0 — явно зробити `raise ValueError("Age cannot be negative")`;  
  - перехопити виняток і вивести повідомлення.  
- Цілі:
  - практичне використання `raise` для сигналізації про некоректні дані;  
  - розуміння різниці між помилками перетворення (`ValueError` при `int()`) і логічною помилкою (негативний вік).

***

## Рекомендований порядок роботи

1. Прочитати цей `README.md`, особливо блок про `try/except/else/finally` та `raise`.
2. Відкрити `exercises.py` і виконати задачі 1–6; задачу 7 залишити як додатковий челендж.  
3. Для кожної задачі:
   - продумати, де саме може статися помилка;  
   - обгорнути проблемний код у `try`;  
   - у `except` обробити **конкретний** тип винятку;  
   - за потреби використати `else` і `finally`.  
4. Перевірити програму з різними даними:
   - ділення на 0 і нормальні числа;  
   - коректні/некоректні цілі числа;  
   - існуючий/неіснуючий файл;  
   - позитивний, нульовий та від’ємний вік.  
5. Після цього відкрити `solutions.py`, порівняти свій підхід з еталонним і звернути увагу:
   - чи не використовується занадто загальний `except Exception`;  
   - чи повідомлення для користувача зрозумілі.  

Цей модуль вчить мислити не тільки «як працює код, коли все добре», а й «що робити, коли щось пішло не так», що є ключовим для написання надійних програм.