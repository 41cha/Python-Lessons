# Module 09: Object-Oriented Programming

У попередніх модулях дані жили в списках, словниках і функціях. **Об’єктно-орієнтоване програмування (OOP)** додає ще один рівень організації: ви описуєте власні типи даних (класи), у яких поруч живуть і дані, і функції, що з ними працюють.

## Клас і об’єкт: «чертеж» і «екземпляр»

- **Клас** — це «чертеж» або шаблон: опис того, які дані (атрибути) і яку поведінку (методи) має мати об’єкт. 
- **Об’єкт (екземпляр)** — це конкретний «екземпляр» класу з конкретними значеннями атрибутів.  

Приклад:

```python
class Person:
    def __init__(self, name, age):
        self.name = name    # атрибути
        self.age = age

    def introduce(self):    # метод
        print(f"Hi, my name is {self.name} and I am {self.age} years old.")

p = Person("Andrii", 20)    # створили об'єкт
p.introduce()
```

Тут `Person` — клас, а `p` — об’єкт цього класу. Методи — це звичайні функції, але «прив’язані» до конкретного об’єкта через перший параметр `self`. 

## __init__ і атрибути: як народжується об’єкт

Метод `__init__` — це «конструктор»: він викликається **автоматично** при створенні об’єкта.

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner      # атрибути екземпляра
        self.balance = balance
```

Ключові моменти:  

- `self` завжди посилається на поточний об’єкт;  
- `self.owner`, `self.balance` — це **атрибути екземпляра**, у кожного об’єкта свої; 
- параметри `owner`, `balance` — просто локальні змінні всередині `__init__`, їх треба зберегти в `self.⋯`.  

Об’єкт створюється викликом класу як функції:

```python
acc = BankAccount("Andrii", 100)
```

Тут фактично викликається `BankAccount.__init__(acc, "Andrii", 100)`. 

## Методи: поведінка, «прив’язана» до даних

Методи — це функції всередині класу, які працюють з атрибутами через `self`:

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height
```

Тут `area()` знає про `width` і `height` **конкретного** прямокутника. Це і є суть:

- дані й операції над ними зібрані разом;  
- не треба передавати купу параметрів у кожну функцію — вони вже є в `self`.

## Інкапсуляція: приховуємо деталі реалізації

**Інкапсуляція** — це ідея «загорнути» дані й методи в клас так, щоб зовнішній код працював через **чіткий інтерфейс**, а не ліз «усередину». 

У Python немає справжніх приватних полів, але є домовленості:  

- атрибут `_password` означає: «не чіпай напряму, працюй через методи»;

```python
class User:
    def __init__(self, username, password):
        self.username = username
        self._password = password   # вважаємо «приватним»

    def check_password(self, password):
        return password == self._password

    def set_password(self, old_password, new_password):
        if self.check_password(old_password):
            self._password = new_password
            print("Password changed successfully")
        else:
            print("Error: old password is incorrect")
```

Ідея: зовнішньому коду не потрібно знати, **як саме** зберігається пароль — важливо, що є методи `check_password` і `set_password`. Якщо пізніше ви зміните реалізацію (хешування паролів), інтерфейс для зовнішнього коду лишиться тим самим. 

## Наслідування: створюємо нові класи на основі існуючих

**Наслідування** дозволяє створити клас-нащадок (child), який успадковує атрибути й методи батьківського класу (parent), доповнюючи або перевизначаючи їх.

Простий приклад:

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print("Some sound")

class Dog(Animal):
    def __init__(self, name):
        super().__init__(name)   # викликаємо __init__ з Animal

    def speak(self):
        print("Woof!")
```

Тут:  

- `Dog(Animal)` означає «Dog наслідує Animal»;  
- `super().__init__(name)` викликає конструктор батьківського класу; 
- метод `speak` у `Dog` **перевизначає** батьківський: тепер собака «говорить» інакше.  

Переваги наслідування: 

- повторне використання коду (не треба копіювати `__init__` з Animal у Dog);  
- можливість будувати ієрархії типів (Animal → Dog, Cat, Bird; Vehicle → Car, Bike);  
- спеціалізація: базовий клас задає «контракт», підкласи реалізують деталі.  

Приклад з `Vehicle` / `Car` у цьому модулі демонструє, як додати своє поле (`year`) і змінити метод `info()`, не переписуючи усе з нуля.  

## Навіщо взагалі потрібні класи

Класи стають реально корисними, коли:

- у вас є дані з очевидною **структурою** (рахунок, користувач, товар, замовлення);  
- є **поведінка**, яка природно «належить» цим даним (deposit/withdraw для рахунку, check_password для користувача, total для кошика);  
- код починає розростатися, і важко зрозуміти, які функції до чого належать.  

Клас дозволяє:

- дати ім’я цьому типу даних;  
- зібрати пов’язані атрибути й методи в одному місці;  
- створювати багато об’єктів одного типу з різними даними (десятки рахунків, сотні користувачів). 

Приклад `ShoppingCart` у цьому модулі показує типовий реальний сценарій: об’єкт інкапсулює внутрішні структури (словник товарів) і надає прості методи `add_item`, `total`, `show`, щоб зовнішній код не думав, «а як там саме воно зберігається всередині».