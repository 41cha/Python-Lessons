# Module 03: Loops

Цикли дозволяють **повторювати** одну й ту саму дію багато разів без копіювання коду. Це основний інструмент для роботи з колекціями (списки, словники), організації багаторазових запитів до користувача, реалізації ігор і простих алгоритмів.

У цьому модулі важливо зрозуміти не тільки синтаксис `for` і `while`, а й **коли який цикл використовувати**, як уникати нескінченних циклів та як керувати ними за допомогою `break` і `continue`.

## Два основні типи циклів

### while: повторювати, поки умова істинна

`while` виконує блок коду **доти, доки** умова істинна:

```python
i = 1
while i <= 5:
    print(i)
    i += 1
```

- перед кожною ітерацією перевіряється умова `i <= 5`;  
- якщо умова істинна — тіло циклу виконується;  
- якщо хибна — цикл завершується.  

Типові випадки для `while`:

- ви **не знаєте заздалегідь**, скільки разів потрібно повторити (наприклад, гра, поки користувач не вгадає число);  
- цикли, які залежать від динамічної умови («поки користувач не введе `exit`», «поки підключення активне»).  

Класична помилка — забути змінювати змінну в умові (наприклад `i += 1`), що веде до нескінченного циклу.

***

### for: перебір елементів послідовності

`for` використовується, коли ми хочемо пройтись по **кожному елементу** послідовності або діапазону значень.

```python
for item in ["apple", "banana", "orange"]:
    print(item)
```

У поєднанні з `range()`:

```python
for i in range(1, 6):
    print(i)
```

- `range(1, 6)` генерує числа 1, 2, 3, 4, 5;  
- це зручно, коли кількість повторів **заздалегідь відома**.

Типові випадки для `for`:

- перебір списку, рядка, словника;  
- виконання дії N разів (`for i in range(N)`);  
- генерація таблиць (таблиця множення, сумування від 1 до N тощо).  

***

## Коли обрати for, а коли while

Корисне правило:

- **for** — коли ви знаєте, *по чому* ітеруєтесь (список, діапазон, рядок), і кількість кроків обмежена;  
- **while** — коли ітерації залежать від деякої **умови**, яку не так просто виразити як «усі елементи списку» або фіксоване `range`.  

Приклади:

- «Вивести числа від 1 до 10» → природно `for i in range(1, 11)`.  
- «Запитувати пароль до 3 разів» → `while attempts < 3`.  
- «Гра, поки користувач не вгадає число» → `while True` з `break` при вгадуванні.

***

## break і continue: тонке керування циклом

Іноді потрібно вийти з циклу раніше або пропустити окрему ітерацію. Для цього є `break` і `continue`.

### break — вийти з циклу

```python
for i in range(10):
    if i == 5:
        break
    print(i)
# Виведе: 0 1 2 3 4
```

- `break` **миттєво перериває** поточний цикл;  
- корисно, коли знайдено потрібне значення, користувач вгадав число, введено команду «вийти».

### continue — пропустити ітерацію

```python
for i in range(6):
    if i == 3:
        continue
    print(i)
# Виведе: 0 1 2 4 5
```

- `continue` пропускає **решту коду** в тілі циклу для цієї ітерації і переходить до наступної;  
- корисно для фільтрації — наприклад, пропустити всі від’ємні числа, некоректні записи тощо. 

***

## Цикли + умови = основний робочий інструмент

Справжня сила з’являється, коли `for`/`while` комбінуються з `if`:

- обійти список і порахувати тільки певні елементи (наприклад, парні числа);  
- виконати дію, доки не виконана якась умова (гра «вгадай число»);  
- пройтись по списку й вийти, щойно знайдено те, що потрібно.  

Приклади патернів:

- **лічильник**: `total = 0` + цикл, де ви робите `total += value`;  
- **пошук**: цикл + `if` + `break`, коли знайдено;  
- **фільтрація**: цикл + `if` + `continue`, щоб пропустити непотрібні елементи. 

***

## Про нескінченні цикли

Нескінченний цикл — це цикл, в якому умова **ніколи не стає хибною**, тому код крутиться вічно (або до вручну перерваного виконання).

Приклади:

```python
while True:
    # потрібен break всередині, інакше цикл не завершиться
    ...
```

```python
i = 0
while i < 5:
    print(i)
    # забули i += 1 → нескінченний цикл
```

Нескінченні цикли **не завжди погані** — наприклад, сервер, який постійно слухає запити, — але в навчальних задачах це зазвичай помилка, якщо ви не використовуєте усвідомлений `while True` з `break`.

***

## Чому цей модуль важливий

Цикли — один із трьох «китів» імперативного програмування (разом з умовами і змінними). Практично все далі буде спиратися на них: 

- обхід списків і словників;  
- обробка файлів рядок за рядком;  
- прості алгоритми (пошук максимуму, сортування, агрегації);  
- симуляції, ігри, взаємодія з користувачем у консолі.

Коли ви **інтуїтивно** відчуваєте, коли використовувати `for`, а коли `while`, і вмієте керувати циклом через `break` і `continue`, наступні теми (структури даних, файли, алгоритми) стають значно простішими.
## Огляд вправ модуля

У цьому модулі 7 вправ, які послідовно тренують різні аспекти роботи з циклами.

### Task 1: Count from 1 to N (while)

- Ввід: ціле число `N > 0`.  
- Поведінка: вивести всі числа від 1 до N включно, використовуючи цикл `while`.  
- Цілі:
  - створення лічильника (`i = 1`);  
  - збільшення лічильника на кожній ітерації (`i += 1`);  
  - практика базового `while`.  

### Task 2: Multiplication table (for + range)

- Ввід: число `n`.  
- Поведінка: вивести таблицю множення для `n` від 1 до 10 у форматі  
  `n x 1 = ...`, `n x 2 = ...`, ... , `n x 10 = ...`.  
- Цілі:
  - використання `for i in range(1, 11)`;  
  - побудова рядків з f-рядками та множенням.  

### Task 3: Sum of numbers from 1 to N

- Ввід: число `N`.  
- Поведінка: обчислити суму `1 + 2 + 3 + ... + N` і вивести результат.  
- Цілі:
  - змінна-акумулятор `total = 0`;  
  - поступове додавання в циклі `total += i`;  
  - розуміння типового патерну "обчислення суми в циклі". 

### Task 4: Count even numbers in a list

- Ввід: список чисел (заданих у коді).  
- Поведінка: порахувати, скільки в списку парних чисел, та вивести цю кількість.  
- Цілі:
  - перебір елементів списку через `for number in numbers`;  
  - перевірка на парність `number % 2 == 0`;  
  - ще один приклад використання лічильника всередині циклу.

### Task 5: Password attempts (while + break)

- Ввід: спроби введення пароля від користувача.  
- Правила:
  - правильний пароль зберігається в змінній `secret`, наприклад `"python123"`;  
  - користувач має максимум 3 спроби;  
  - якщо пароль введено вірно — вивести `"Access granted"` і завершити цикл;  
  - якщо після 3 спроб користувач не вгадав — вивести `"Access denied"`.  
- Цілі:
  - використання лічильника спроб;  
  - цикл `while` з умовою на кількість спроб;  
  - достроковий вихід із циклу через `break`, якщо пароль вірний. 

### Task 6: Skip negative numbers (continue)

- Ввід: список чисел (заданих у коді).  
- Поведінка: вивести тільки ті числа зі списку, які **не є негативними** (тобто `>= 0`).  
- Цілі:
  - фільтрація елементів у циклі;  
  - використання `continue` для пропуску небажаних значень.

### Task 7 (optional): Simple guessing game

- Правила гри:
  - у змінній `secret` зберігається секретне число, наприклад `7`;  
  - програма у циклі запитує у користувача припущення;  
  - якщо число менше `secret` – виводить `"Too low"`;  
  - якщо більше – `"Too high"`;  
  - якщо дорівнює – `"You guessed it!"` і гра закінчується.  
- Цілі:
  - побудова циклу `while True` з перевіркою умов усередині;  
  - завершення гри через `break`;  
  - типова структура гри на вгадування, часто показувана в туторіалах по while-циклах.

***

## Рекомендований порядок роботи

1. Уважно прочитати теоретичні блоки про `while`, `for`, `range()`, `break`, `continue`.  
2. Відкрити `exercises.py` і виконати задачі послідовно з 1 по 6; задачу 7 можна залишити як «челендж» або домашнє завдання.  
3. Для кожної задачі:
   - реалізувати розв’язок замість `# TODO: your code here`;  
   - протестувати його з різними значеннями (наприклад, N = 1, 5, 10; порожні паролі; різні списки чисел).  
4. Після цього відкрити `solutions.py`, порівняти власні рішення з прикладами та звернути увагу:
   - чи можна спростити цикл;  
   - чи достатньо зрозумілі імена змінних;  
   - чи коректно обробляються граничні випадки (наприклад, N = 0 або неправильний пароль).  

Модуль 03 закладає основу для всіх наступних тем: робота з колекціями, обробка файлів, парсери й навіть базові алгоритми майже завжди спираються на цикли.