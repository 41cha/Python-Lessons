# Module 04: Functions

Коли код росте, копіювати ті самі фрагменти знову й знову стає небезпечно й незручно. **Функції** дозволяють оформити логіку в іменовані «блоки», які можна викликати багато разів із різними даними. Це фундамент для чистого, модульного коду. 

## Що таке функція

Функція — це **іменований блок коду**, який: 

- має **ім’я**;  
- може приймати **вхідні дані** (параметри);  
- може **повертати результат** через `return`;  
- виконується тільки тоді, коли її **викликають**.  

```python
def greet(name):
    print(f"Hello, {name}!")

greet("Andrii")  # виклик
```

Це як «маленька програма» всередині вашої програми: вона робить одну чітку дію, а решта коду просто каже «зроби це ще раз, але з такими даними».

***

## Параметри й аргументи

### Позиційні параметри

У визначенні функції ми задаємо **параметри**:

```python
def add(a, b):
    return a + b
```

При виклику ми передаємо **аргументи**:

```python
result = add(10, 5)  # a=10, b=5
```

Тут порядок важливий: перший аргумент → перший параметр, другий → другий і т.д.

***

### Значення за замовчуванням

Іноді деякі параметри мають «типове» значення:

```python
def info(name, age=18, city="Unknown"):
    print(name, age, city)

info("Andrii")               # Andrii 18 Unknown
info("Maria", 25)            # Maria 25 Unknown
info("Oleh", 30, "Kyiv")     # Oleh 30 Kyiv
```

- параметри з `=` мають значення за замовчуванням;  
- їх можна не вказувати при виклику — тоді використається default;  
- параметри без значень за замовчуванням завжди мають бути **ліворуч**.

Це дозволяє робити функції гнучкими: головні аргументи обов’язкові, усе інше — опційне.

***

### *args: довільна кількість аргументів

Якщо ви не знаєте наперед, скільки значень захочете передати, використовуйте `*args`:

```python
def sum_all(*numbers):
    return sum(numbers)

sum_all(1, 2, 3)        # 6
sum_all(10, 20, 30, 40) # 100
```

Всередині функції `numbers` — це кортеж усіх переданих позиційних аргументів. Це корисно для функцій типу «сума всіх», «об’єднай усе», де кількість аргументів не фіксована.

***

## return: як функція повертає результат

Функція може **повертати** значення через `return`:

```python
def circle_area(radius):
    return 3.1416 * radius * radius

area = circle_area(5)
```

- `return` завершує функцію й повертає значення;  
- все, що після `return` у тілі, вже не виконується;  
- якщо `return` немає, функція повертає `None`.  

Функція може повертати й **кілька значень** (зазвичай у вигляді кортежу):

```python
def get_point():
    return 3, 5

x, y = get_point()
```

Це дає змогу оформлювати обчислення в компактні «чорні ящики»: функція отримала параметри → повернула результат.

***
## Розширені параметри: **kwargs

Окрім `*args` для довільної кількості позиційних аргументів, є `**kwargs` — довільна кількість **іменованих** аргументів.

```python
def print_user(**info):
    print(info)

print_user(name="Andrii", age=20)
# {'name': 'Andrii', 'age': 20}
```

- всередині функції `info` — це словник `dict`, де ключі — імена параметрів, значення — те, що передали при виклику;  
- це корисно, коли набір полів може змінюватися: додавати нові опції без зміни сигнатури функції. 

Часто комбінують `*args` і `**kwargs`, коли хочуть написати «універсальну» обгортку чи декоратор, що приймає будь‑які аргументи. 

***

## Порядок параметрів у функції

Коли ви комбінуєте позиційні параметри, значення за замовчуванням, `*args` та `**kwargs`, важливий **порядок**: 

```python
def func(pos1, pos2, *args, kw1="default", **kwargs):
    ...
```

Загальне правило:

1. Звичайні позиційні параметри (без `=`).  
2. Параметр `*args`.  
3. Параметри з значеннями за замовчуванням (і keyword‑only, якщо використовувати `*`, але це вже advanced).  
4. Параметр `**kwargs`.  

Це допомагає Python однозначно зрозуміти, що куди потрапляє при виклику функції.

***


## Область видимості (scope): локальні vs глобальні змінні

Scope визначає, **де змінна доступна**: 

- **локальна змінна** — оголошена всередині функції, доступна тільки там;  
- **глобальна змінна** — оголошена зовні, доступна по всьому модулю (але змінювати її з функції треба обережно).  

```python
x = 10  # глобальна

def foo():
    x = 5  # локальна, інша змінна
    print(x)  # 5

foo()
print(x)  # 10
```

Це дозволяє функціям бути **ізольованими**: вони працюють зі своїми даними і не ламають випадково зовнішній стан. Хороший стиль — передавати в функцію все, що їй потрібно, через параметри, а не тягнути глобальні змінні. 

***

## Чому функції важливі

Функції — це основний інструмент:

- **повторного використання** коду (DRY: Don’t Repeat Yourself);
- **структурування** великих програм на менші логічні частини; 
- **тестованості**: простіше перевірити окрему функцію, ніж монолітний скрипт;  
- **абстракції**: ви ховаєте реалізацію (як саме рахується факторіал чи площа), залишаючи лише інтерфейс (`factorial(n)`, `circle_area(r)`).  

Усі наступні теми — робота з файлами, мережеві запити, ООП, тестування — будуть спиратися на те, що ви вмієте оформлювати логіку у функції з чіткими параметрами і результатом.

## Огляд вправ модуля

У модулі 7 вправ, які поступово ускладнюють роботу з функціями.

### Task 1: Simple greeting function

- Створити функцію `greet(name)`, яка виводить привітання.  
- Цілі: базовий синтаксис `def`, один параметр, виклик функції.  

### Task 2: Area of circle

- Створити `circle_area(radius)`, яка повертає площу кола (\(πr^2\)).  
- Цілі: `return`, імпорт `math`, математичні обчислення у функції.  

### Task 3: Factorial function

- Створити `factorial(n)`, яка обчислює факторіал (1 × 2 × ... × n).  
- Особливий випадок: `0! = 1`.  
- Цілі: цикл усередині функції, обробка граничних випадків.  

### Task 4: Calculator functions

- Створити 4 функції: `add()`, `subtract()`, `multiply()`, `divide()`.  
- У `divide()` обробити ділення на 0.  
- Цілі: кілька функцій в одному файлі, різні типи обчислень.  

### Task 5: Is prime number

- Створити `is_prime(n)`, яка повертає `True`, якщо число просте.  
- Оптимізація: перевіряти дільники тільки до \(\sqrt{n}\).  
- Цілі: логіка всередині функції, булеві значення як результат.  

### Task 6: Default parameters

- Створити `info(name, age=18, city="Unknown")`.  
- Протестувати з 1, 2, 3 аргументами.  
- Цілі: параметри з значеннями за замовчуванням.  

### Task 7 (optional): Variable arguments (*args)

- Створити `sum_all(*numbers)`, яка сумує будь-яку кількість чисел.  
- Цілі: робота з `*args`, функція `sum()`, гнучкість параметрів.  

***

## Рекомендований порядок роботи

1. **Вивчити теорію**: розібратися з `def`, `return`, параметрами, `*args`.  
2. **Практика**: відкрити `exercises.py` і виконати задачі послідовно.  
3. **Для кожної задачі**:
   - Спочатку прочитати умову та підказки.  
   - Написати функцію замість `# TODO`.  
   - Протестувати виклик функції з різними значеннями.  
   - Перевірити граничні випадки (0, від’ємні числа, некоректні дані).  
4. **Перевірка**: після всіх вправ відкрити `solutions.py` і порівняти підходи.  
5. **Рефакторинг**: спробувати покращити власний код (кращі імена змінних, документація, обробка помилок).  

**Важливо**: у `solutions.py` використовується `import math` — не забудьте додати його для задач 2 і 5!

***

Функції — основа модульного програмування. Навички з цього модуля знадобляться у всіх наступних темах: від роботи з файлами до об'єктно-орієнтованого програмування